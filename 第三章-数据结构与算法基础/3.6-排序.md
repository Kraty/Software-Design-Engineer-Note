### 内部排序
  > **稳定性**:当K<sub>i</sub>=K<sub>j</sub>，经过排序后保持K<sub>i</sub>，K<sub>j</sub>的相对位置不变，称为**稳定的**,否则称为**不稳定的**
  + 性能比较
  
  |排序方法|时间复杂度|辅助空间|稳定性|
  |:-----|:-----:|:-----:|-----:|
  |直接插入|O<sub>(n<sup>2</sup>)</sub>|O<sub>(1)</sub>|稳定|
  |简单选择||||
  |冒泡排序|O<sub>(n<sup>2</sup>)</sub>|O<sub>(1)</sub>|稳定|
  |希尔排序||||
  |快速排序||||
  |堆排序||||
  |归并排序||||
  |基数排序||||
### 简单排序
  + 直接插入排序★★★
  
  |下标|0|1|2|...|n-2|n-1|
  |:---|:---:|:---:|:---:|:---:|:---:|:---:|
  |数值|D<sub>1</sub>|D<sub>2</sub>|D<sub>3</sub>|...|D<sub>n-1</sub>|D<sub>n</sub>|
  
  + 为什么叫**插入排序**
    > 初始状将D<sub>1</sub>看做一个已排序序列(数组)，因为初始状态只有一个元素，所以是**有序的**<br>
      其他元素(D<sub>2</sub>,D<sub>3</sub>,...,D<sub>n-1</sub>,D<sub>n</sub>)组成一个待插入的序列(数组)<br>
      将待插入元素一个一个的和已排序序列中的元素进行比较
    
  ```java
  void InsertSort(int data[],int n)
    {
      int i,j;
      int temp;
      for(i=1;i<n;i++){
        if(data[i]<data[i-1]){ /
          temp=data[i]; /
          for(j=i-1;j>=0&&data[j]>temp;j--){ /
            data[j+1]=data[j]; /
          }
          data[j+1]=temp; /
        }
      }
    }
  ```

