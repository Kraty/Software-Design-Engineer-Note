### 内部排序
  > **稳定性**:当K<sub>i</sub>=K<sub>j</sub>，经过排序后保持K<sub>i</sub>，K<sub>j</sub>的相对前后位置不变(元素之间的距离可以变)，称为**稳定的**,否则称为**不稳定的**
  >> 例如:序列5 8 5 2 9，在选择排序中我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以**选择排序**不稳定<br>
      在冒泡排序中，两个5最后结果前后顺序并未发生改变，所以**冒泡排序**是稳定的
  + 性能比较
  
  |排序方法|时间复杂度|辅助空间|稳定性|
  |:-----|:-----:|:-----:|-----:|
  |直接插入|O<sub>(n<sup>2</sup>)</sub>|O<sub>(1)</sub>|稳定|
  |简单选择||||
  |冒泡排序|O<sub>(n<sup>2</sup>)</sub>|O<sub>(1)</sub>|稳定|
  |希尔排序||||
  |快速排序||||
  |堆排序||||
  |归并排序||||
  |基数排序||||
### 简单排序
  + 直接插入排序★★★
  
    |下标i|0|1|2|...|n-2|n-1|
    |:---|:---:|:---:|:---:|:---:|:---:|:---:|
    |数值|D<sub>1</sub>|D<sub>2</sub>|D<sub>3</sub>|...|D<sub>n-1</sub>|D<sub>n</sub>|

    + 为什么叫**插入排序**
      > 初始状将D<sub>1</sub>看做一个已排序序列(数组)，因为初始状态只有一个元素，所以是**有序的**<br>
        其他元素(D<sub>2</sub>,D<sub>3</sub>,...,D<sub>n-1</sub>,D<sub>n</sub>)组成一个待插入的序列(数组)<br>
        将待插入元素一个一个的和已排序序列中的元素进行比较
    + 代码实现
      > 以下代码为实现数组中元素递增排序
    ```java
    void InsertSort(int data[],int n)
      {
        int i,j;
        int temp;
        /从左往右开始遍历待插入元素的原因是为了实现结果数组为递增，如果要实现最后数组为递减，则需要从右往左遍历，那么最右第一个元素为初始化已排序序列
        for(i=1;i<n;i++){ /第一个元素为已排序序列，需要从第二个元素开始依次拿取元素到已排序序列中对比
          if(data[i]<data[i-1]){ /进入已排序序列中的条件是:待插入元素比已排序数组中的最后一个值要小
            temp=data[i]; /取出待插入元素
            for(j=i-1;j>=0&&data[j]>temp;j--){ /开始进入已排序数组中的元素和待插入数据的对比循环，在已排序序列中从右往左的元素跟temp比较大小
              data[j+1]=data[j]; /如果比temp大，那么已排序序列中该位置的元素就需要后移一位
            }
            data[j+1]=temp; /当到了data[j]<temp的时候，或者已经到数组的左边时候j<0了，此时temp的元素就该放在data[j]的右边
          }
        }
      }
    ```
  + 冒泡排序★★★
    + 为什么叫**冒泡**
      > 前后元素对比大小，满足相应条件后，交换两个元素的位置，直到D<sub>n-1</sub>和D<sub>n</sub>对比后，D<sub>n</sub>位置就是最大的一个或者最小的一个元素
    + 代码实现
      > 以下代码为实现数组中元素递增排序<br>
        冒泡排序实现的方法有多种
      ```java
      void BubbleSort(int data[],int n)
        {
          int i,j;
          int temp;
          for(i=n-1;i>=0;i--){
            for(j=1;j<=i;j++){
              if(data[j-1]>data[j]){
                temp=data[j];
                data[j]=data[j-1];
                data[j-1]=temp;
              }
            }
          }
        }
      ```
   + 选择排序★★★
     + 为什么叫**选择**
     
        |下标i|0|1|2|...|n-2|n-1|
        |:---|:---:|:---:|:---:|:---:|:---:|:---:|
        |数值|D<sub>1</sub>|D<sub>2</sub>|D<sub>3</sub>|...|D<sub>n-1</sub>|D<sub>n</sub>|
        |第一趟比较区间|**D<sub>1</sub>**|D<sub>2</sub>|D<sub>3</sub>|...|D<sub>n-1</sub>|D<sub>n</sub>|
        |第二趟比较区间||**D<sub>2</sub>**|D<sub>3</sub>|...|D<sub>n-1</sub>|D<sub>n</sub>|
        |第三趟比较区间|||**D<sub>3</sub>**|...|D<sub>n-1</sub>|D<sub>n</sub>|
        |...|||||||
        |第n-1趟比较区间|||||**D<sub>n-1</sub>**|D<sub>n</sub>|
       > 通过比较每个比较区间内的相邻两个元素大小，**选择**元素值最大或者最小的元素的下标存入temp，将每一趟比较结果(最大或者最小)的元素值放置在相应区间内的头部或者尾部来实现排序
      + 代码实现
        > 以下代码为实现数组中元素递增排序
        ```java
        void SelectSort(int data[],int n)
          {
            int i,j,k,tmp;
            for(i=0;i<n-1;i++){
              k = i;
              for(j=i+1;j<n;j++){
                if(data[j]<data[k]){
                  k=j;
                }
              }
              if(k!=i){
                tmp=data[i];
                data[i]=data[k];
                data[k]=tmp;
              }
            }
        }
      ```
   + 希尔排序★★★
     + 也叫**缩小增量排序**
