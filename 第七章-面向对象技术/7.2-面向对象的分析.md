### 分析和设计原则
  + 抽象
  + 信息隐蔽
  + 功能独立
  + 模块化
### 面向对象的分析 OOA
  + 认定对象
    > 自然存在的实体确立对象
  + 组织对象
    > 将相关对象抽象成类，通过继承性建立具体对象类的的层次结构
  + 对象间的相互作用
  + 基于对象的操作
### 面向对象的设计 OOD
  > 将**面向对象分析OOA**所创建的分析模型转化成**设计模型**
    + 识别类及对象
    + 定义属性
    + 定义服务(方法)
    + 识别关系
    + 识别包
  + 面向对象设计原则
    
    |缩写|原则|全称|说明|
    |:---|:---:|:---:|---:|
    |SRP|[单一职责原则](https://www.cnblogs.com/gaochundong/p/interface_segregation_principle.html)|Single Responsibility Principle|要修改某个类的原因有且只有一个<br>让一个类只做一种类型的责任|
    |OCP|[开放封闭原则](https://www.cnblogs.com/gaochundong/p/open_closed_principle.html)|Open Closed Principle|软件实体（类、模块、函数等）应对扩展开放<br>但对修改封闭|
    |LSP|[里氏替换原则](https://www.cnblogs.com/gaochundong/p/liskov_substitution_principle.html)|Liskov Substitution Principle|使用基类对象指针或引用的函数<br>必须能够在不了解衍生类的条件下使用衍生类的对象|
    |ISP|[接口分离原则](https://www.cnblogs.com/gaochundong/p/interface_segregation_principle.html)|Interface Segregation Principle|类的接口可以被分解为多组功能函数的组合，<br>每一组都服务于不同的客户类，<br>而不同的客户类可以选择使用不同的功能分组|
    |LKP|[最少知识原则](https://www.cnblogs.com/gaochundong/p/least_knowledge_principle.html)|Least Knowledge Principle|每个单元对其他单元只拥有有限的知识<br>只了解与当前单元紧密联系的单元|
    |||||
  
    + SRP单一职责原则:`要修改某个类的原因有且只有一个，让一个类只做一种类型的责任`
    + OCP开放-封闭原则:`对扩展开放(继承、子类重写不影响父类)，对修改(不能对基类功能、函数、模块、数据直接修改)封闭`
    + LSP里氏(Liskov)替换原则:`子类可以替换父类<br>使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象`
    + [DIP依赖倒置原则](https://blog.csdn.net/yabay2208/article/details/73826719):`类的接口可以被分解为多组功能函数的组合，每一组都服务于不同的客户类，而不同的客户类可以选择使用不同的功能分组`
    + ISP接口分离原则:``
    ---
    + ISP组合重用原则:`就是说要尽量的使用合成和聚合，而不是继承关系达到复用的目的，组合能更好的实现封装，比继承具有更大的灵活性和更稳定的结构。
该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。
继承的耦合比组合要高`
    + 迪米特(Demeter)原则(最少知识法则):`保持对象的独立性`
