## 创新型模式
  ### 类
  + [**工厂方法模式（factory method）**](https://www.jianshu.com/p/d0c444275827)
    > 基于简单工厂模式，优化了简单工厂模式的缺点<br>
      **工厂方法模式**可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现
    + UML类图
    
    ![7-24](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-24.jpg)
  ### 对象
  + [**抽象工厂模式（abstract factory）**](https://www.jianshu.com/p/7deb64f902db)
    > 抽象工厂模式与工厂方法模式最大的区别，**抽象工厂**中每个工厂可以创建**多种类**的产品，而**工厂方法**每个工厂只能创建**一类**
    + UML类图
    ![7-25](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-25.png)
  + [**原型模式（prototype）**](https://www.jianshu.com/p/42266549e6f9)
    > 复制一个对象自身，从而克隆出多个与原型对象一模一样的对象<br>
    
    + JAVA中的原型模式
      > 所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份。因此在Java中可以直接使用Object提供的clone()方法来实现对象的克隆。
      + 深拷贝
      ```java
      ArrayList<String> a = new ArrayList();
      ArrayList<String> b = a.clone();
      //或者
      ArrayList<String> c = new ArrayList(a);
      ```
      + 浅拷贝
      ```java
      ArrayList<String> a = new ArrayList();
      ArrayList<String> b = a;
      ```
    + 注意事项
      > 通过实现Cloneable接口的原型模式在调用clone函数构造实例时并不一定比通过new操作速度快，只有当通过new构造对象较为耗时或者说成本较高时，通过clone方法才能够获得效率上的提升，因此，在使用Cloneable时需要考虑构建的成本以及做一些效率上的测试，当然，实现原型模式也不一定非要实现Cloneable接口，也有其他的实现方式      
    + UML类图<br>
      ![7-26](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-26.png)
    + [代码实现](https://www.runoob.com/design-pattern/prototype-pattern.html)
  + [**单利模式★★★（singleton）**](https://www.runoob.com/design-pattern/singleton-pattern.html)
    > 保证一个类仅有一个实例，并提供一个访问它的全局访问点<br>
      降低对象之间的耦合度<br>
      单例类只能有一个实例<br>
      单例类必须自己创建自己的唯一实例<br>
      单例类必须给所有其他对象提供这一实例<br>
    + UML图示<br>
    ![7-27](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-27.jpg)
    + [单例实现方式](https://www.runoob.com/design-pattern/singleton-pattern.html)
      + 懒汉式
        + 线程安全
        + 线程不安全
      + 饿汉式
      + 双重校验锁
      + 登记式/静态内部类
      + [枚举](https://www.cnblogs.com/chiclee/p/9097772.html)
  + [**构建器模式（builder）**](https://www.runoob.com/design-pattern/builder-pattern.html)
    > 使用多个简单的对象一步一步构建成一个复杂的对象<br>
    ![7-28](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-28.jpg)
---
## 结构型模式
  ### 类
  + **适配器模式★★★（adapter）**
    > 作为两个不兼容的接口之间的桥梁<br>
      结合两个独立接口的功能<br>
    ![7-29](https://github.com/flysafely/Software-Design-Engineer-Note/blob/master/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF/%E6%9C%AC%E7%AB%A0%E5%9B%BE%E7%A4%BA/7-29.jpg#div-comment-42319)
  ### 对象
  + **适配器模式★★★（adapter）**
  + **桥接模式（bridge）**
  + **组合模式（composite）**
  + **装饰模式★★★（decorator）**
  + **外观模式（facade）**
  + **享元模式（flyweight）**
  + **代理模式（proxy）**
---
## 行为型模式
  ### 类
  + **解释器模式（interpreter）**  
  + **模板方法模式（template method）**  
  ### 对象
  + **职责链模式★★★（chain of responsibility）**
  + **命令模式★★★（command）**
  + **迭代器模式（iterator）**
  + **中介者模式（mediator）**
  + **备忘录模式（memento）**
  + **观察者模式★★★（observer）**
  + **状态模式（state）**
  + **策略模式★★★（strategy）**
  + **访问者模式（visitor）**
