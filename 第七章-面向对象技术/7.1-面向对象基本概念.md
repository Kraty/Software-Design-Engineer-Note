### 面向对象技术
  + 面向对象的基本概念★★★
    + 对象
      > 基本运行时的**实体**<br>
        数据库ER图中的实体<br>
        属性(数据)+方法(操作)+对象ID(唯一标识一个对象)
    + 类
      > 定义一组大体相似的**对象**<br>
        **类**中包含的是相似**对象**的共同**属性(数据)**、**方法(操作)**<br>
        **对象**是类的具体化<br>
        **对象**是类的实例<br>
        **类**的分类:实体类，接口类(边界类)，控制类<br>
        **类及对象**指类和这个类的所有对象
    + 继承
      > **父类**和**子类**共享复用*属性(数据)*和*方法(操作)*的机制<br>
        **父类**可以有多个**子类**<br>
        **子类**是**父类**的特例
        A是父类，b，c，d是子类，可以说b，c，d**继承**自A
      + 单重继承
        > 从一个父类继承
      + 多重继承
        > 一个子类有多个父类
    + 泛化
      > A是父类，b，c，d是子类，可以说b，c，d泛化自A<br>
        泛化一词在UML中使用频繁
    + 派生
      > A是父类，b，c，d是子类，可以说A可以派生出b，c，d
    + 封装
      > 隐藏**对象**的**属性(数据)**和**方法(操作)细节**，注意是隐藏对象和方法细节，不是隐藏类中的方法和属性！<br>
        对外只提供相应接口(方法)
    + 多态
      > **同一类**的**对象**收到**同一消息**产生完全不同的结果<br>
        用户发送一个通用的消息，实现的细节由接收的**对象**自行决定
    + 动态绑定
      >
    + 消息
      >
    + 消息通信
      >
    + 重载
      >
    + 特殊类
      + 模板类
        > 
      + [接口](https://www.runoob.com/java/java-interfaces.html)
        > 特殊的**抽象类**，只有方法定义，没有方法实现细节
        + **接口**不能被实例化
        + **接口**只能包含方法声明(抽象方法)
        + **接口**的成员包括方法声明、属性、索引器、事件
        + **接口**中不能包含常量、字段(域)、构造函数、析构函数、静态成员(属性、方法)
      + [抽象类](https://www.runoob.com/java/java-abstraction.html)
        > 抽象类不能创建实例，它只能作为父类被继承<br>
          抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象<br>
          以这个抽象类作为其子类的模板，从而避免了子类的随意性
        + **抽象类**可以没有**抽象方法**也可以有，可以有正常的方法(有实现细节)，也可以没有
        + **抽象方法**只作**声明**，而**不包含实现**，可以看成是没有实现体的**虚方法**
        + **抽象类**不能被**实例化**
        + **抽象类**可以但不是必须有**抽象属性**和**抽象方法**，但是一旦有了**抽象方法**，就一定要把这个类声明为**抽象类**
        + **具体派生类**必须**覆盖、实现**基类的**抽象方法**
        + **抽象派生类**(继承某抽象类的子类)可以覆盖基类的**抽象方法**，也可以不覆盖。如果不覆盖，则其**具体派生类**的子类必须**覆盖、实现**它们
      + 接口和抽象类的异同
        + 区别:
          + **抽象类**可以有**构造方法(有具体实现细节)**，接口中不能有**构造方法**。
          + **抽象类**中可以有**普通成员变量**，**接口**中没有**普通成员变量**
          + **抽象类**中可以包含**静态方法**，**接口**中不能包含**静态方法**
          + 一个类可以**实现多个接口**，但只能继承一个**抽象类**。
            ```java
            ...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...
            ```
          + 继承**抽象类**用 extends 关键字；实现**接口**用 implements 关键字。继承写在前面，实现接口写在后面
            ```java
            class className extends abstractClassName implements interfaceName1,interfaceName2,...{
                ...
            }
            ```
          + 接口可以被多重实现，抽象类只能被单一继承
          + 如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法
        + 相同:
          + 都可以被继承
          + 都不能被实例化
          + 都可以包含方法声明(抽象方法)
          + 派生类必须实现未实现的方法(抽象方法)
