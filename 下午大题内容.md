### UML图和数据流图
### ER模型
### 类图填空
### 算法填空
  + 分治法
  + 贪心法
  + 动态规划法
  + 回溯法
### 设计模式的代码实现
  + **创建型模式**
    + 单例模式：`保证一个类仅有一个实例，并提供一个访问它的全局访问点`
    + 工厂方法模式FactoryMethod：`定义一个用于创建对象的接口，让子类决定实例化哪一个类`
    + **※抽象工厂模式AbstractFactory※**：`提供一个创建一系列相关或者相互依赖对象的接口，无需指定他们的具体类`
    + **※建造者模式(生成器)Bulider※**：`讲一个复杂对象的构建与它的表示相分离，同样的构建过程可以创建不同的表示`
    + **※原型模式Prototype※**：`用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象`
  + 结构型模式
    + **※适配器模式Adapter※**：`将一个类的接口转换成客户希望的另外一个接口`
    + **※桥接模式※**：`将抽象的部分与其实现的部分相分离，使他们可以独立变化，将N*M转化成N+M组合的思想`
    + **※装饰器模式Decorator※**：`允许向一个现有的对象添加新的功能，同时又不改变其结构`
    + [**※组合模式Compostie※**](https://www.bilibili.com/video/av63681488/?p=78)：`一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性`
    + 外观模式：``
    + 享元模式：``
    + **※代理模式Proxy※**：`为其他对象提供一种代理以控制对这个对象的访问`
  + 行为型模式
    + 模板方法模式：``
    + **※命令模式※**：``
    + 迭代器模式：``
    + **※观察者模式Observer※**：`定义对象间的一种一对多的依赖关系`
    + 中介者模式：``
    + 备忘录模式：``
    + 解释器模式：``
    + **※状态模式※**：``
    + **※策略模式※**：`定义一系列算法，把他们一个一个的封装起来，并且使他们可以相互替换`
    + 职责链模式：``
    + **※访问者模式※**：``
